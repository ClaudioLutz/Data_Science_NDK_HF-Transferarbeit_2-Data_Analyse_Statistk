---
title: "Shab-Analyse"
author: "Claudio Lutz"
date: "2024-07-28"
output:
  html_document: default
  pdf_document: default
---


## Einführung

### HR01

Dieser Code wird für die Registrierung neuer Unternehmen im Handelsregister verwendet. Wenn ein neues Unternehmen gegründet und registriert wird, erfolgt die Veröffentlichung unter HR01. Dies umfasst Details wie den Firmennamen, den Sitz, den Zweck und die Namen der Verwaltungsratsmitglieder oder Geschäftsführer.

### HR03

Dieser Code bezieht sich auf die Löschung eines Unternehmens aus dem Handelsregister. Dies geschieht, wenn ein Unternehmen aufgelöst, liquidiert oder anderweitig nicht mehr als registrierte Einheit existiert. Die Löschung muss beantragt werden, wenn beispielsweise ein Einzelunternehmen nicht mehr existiert oder an eine andere Person übergeht.

Weitere Informationen zu den Eintragungspflichten und -verfahren befinden sich auf folgender Seite:

- [Handelsregister: Rechte und Pflichten für KMU](https://www.kmu.admin.ch/kmu/de/home/praktisches-wissen/kmu-gruenden/firmengruendung/handelsregister.html)


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.width=10, fig.height=6)
```

```{r installiere_libraries, echo=TRUE, results='hide', message=FALSE, warning=FALSE}
if (!require(tidyr)) install.packages("tidyr")
if (!require(httr)) install.packages("httr")
if (!require(XML)) install.packages("XML")
if (!require(dplyr)) install.packages("dplyr")
if (!require(ggplot2)) install.packages("ggplot2")
if (!require(gridExtra)) install.packages("gridExtra")
if (!require(patchwork)) install.packages("patchwork")
if (!require(skimr)) install.packages("skimr")
if (!require(broom)) install.packages("broom")
if (!require(forecast)) install.packages("forecast")
if (!require(scales)) install.packages("scales")
if (!require(tidyr)) install.packages("tidyr")
if (!require(tidytext)) install.packages("tidytext")
```


```{r lade_libraries, echo=TRUE, results='hide', message=FALSE, warning=FALSE}
library(httr)
library(XML)
library(ggplot2)
library(dplyr)
library(gridExtra)
library(lubridate)
library(patchwork)
library(skimr)
library(broom)
library(forecast)
library(scales)
library(tidyr)
library(tidytext)
source("get_shab_data.R")
```


```{r lade_daten_falls_nötig, warning=FALSE}
# Scrape alle relevanten Shab-Daten über einen Zeitraum. Es werden nur die Daten herunterladen welche noch nicht lokal gespeichert sind.
from_date <- as.Date("2018-03-18")
to_date <- as.Date("2024-08-25")
shab_data <- Get_Shab_DF_from_range(from_date, to_date)

# Display the data
skim(shab_data)
```
```{r}
head(shab_data)
```
```{r Monthly_SubRubric_count}
data <- shab_data


# Convert 'date' column to Date type and extract month and quarter
data$date <- as.Date(data$date)
data$month <- format(data$date, "%Y-%m")
data$quarter_label <- paste0(year(data$date), "_Q", quarter(data$date))

# Aggregate data by month and subrubric
agg_data <- data %>%
  group_by(month, subrubric) %>%
  summarise(count = n(), .groups = "drop")

# Ensure all months have both subrubrics (HR01 and HR03)
all_months <- unique(agg_data$month)
all_subrubrics <- c("HR01", "HR03")
complete_data <- expand.grid(month = all_months, subrubric = all_subrubrics) %>%
  left_join(agg_data, by = c("month", "subrubric")) %>%
  mutate(count = ifelse(is.na(count), 0, count))

# Generate the sequence of months that are the start of each quarter
start_of_quarters <- unique(complete_data$month[month(as.Date(paste0(complete_data$month, "-01"))) %% 3 == 1])

# Calculate the difference between HR01 and HR03 as Netto Zuwachs
difference_data <- complete_data %>%
  spread(key = subrubric, value = count) %>%
  mutate(NettoZuwachs = HR01 - abs(HR03)) %>%
  select(month, NettoZuwachs)

# Merge the difference data back with the complete_data
final_data <- complete_data %>%
  left_join(difference_data, by = "month") %>%
  mutate(quarter_label = ifelse(month %in% start_of_quarters, paste0(substr(month, 1, 4), "_Q", quarter(as.Date(paste0(month, "-01")))), ""),
         month = factor(month, levels = unique(month)))  # Convert month to a factor

# Transform counts: HR03 to negative values
final_data <- final_data %>%
  mutate(count = ifelse(subrubric == "HR03", -count, count))

# Plot HR01 and HR03 with stacking
p <- ggplot(final_data, aes(x = month)) +
  geom_col(aes(y = count, fill = subrubric), position = "stack") +
  geom_hline(yintercept = 0, color = "black") +
  scale_y_continuous(labels = abs) +
  scale_x_discrete(labels = final_data$quarter_label) +
  scale_fill_manual(values = c("HR01" = "Darkgreen", "HR03" = "#FF474C", "Netto Zuwachs" = "gray50")) +
  labs(
    title = "Monthly Subrubric Counts with Netto Zuwachs",
    x = "Month",
    y = "Number of Records",
    fill = "Subrubric"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    panel.grid.major.y = element_line(color = "grey80"),
    panel.grid.minor.y = element_blank()
  )

# Add Netto Zuwachs as a separate bar without stacking
p + geom_col(data = final_data, aes(x = month, y = NettoZuwachs, fill = "Netto Zuwachs"), width = 0.3, color = "black", position = position_dodge(width = 0.9))
```
```{r}


# Group the data by Kanton and subrubric, then aggregate
agg_data_kanton <- data %>%
  group_by(kanton, subrubric) %>%
  summarise(count = n(), .groups = "drop")

# Ensure all Kantons have both subrubrics (HR01 and HR03)
all_kantons <- unique(agg_data_kanton$kanton)
all_subrubrics <- c("HR01", "HR03")
complete_data_kanton <- expand.grid(kanton = all_kantons, subrubric = all_subrubrics) %>%
  left_join(agg_data_kanton, by = c("kanton", "subrubric")) %>%
  mutate(count = ifelse(is.na(count), 0, count))

# Calculate the difference between HR01 and HR03 as Netto Zuwachs
difference_data_kanton <- complete_data_kanton %>%
  spread(key = subrubric, value = count) %>%
  mutate(NettoZuwachs = HR01 - abs(HR03)) %>%
  select(kanton, NettoZuwachs)

# Merge the difference data back with the complete_data
final_data_kanton <- complete_data_kanton %>%
  left_join(difference_data_kanton, by = "kanton") %>%
  arrange(NettoZuwachs, kanton) %>%  # Break ties by alphabetical order of Kanton
  mutate(kanton = factor(kanton, levels = unique(kanton)))  # Convert kanton to a factor with ordered levels

# Transform counts: HR03 to negative values
final_data_kanton <- final_data_kanton %>%
  mutate(count = ifelse(subrubric == "HR03", -count, count))

# Plot HR01 and HR03 with stacking
p <- ggplot(final_data_kanton, aes(x = kanton)) +
  geom_col(aes(y = count, fill = subrubric), position = "stack") +
  geom_hline(yintercept = 0, color = "black") +
  scale_y_continuous(labels = abs) +
  scale_fill_manual(values = c("HR01" = "#1f77b4", "HR03" = "#ff7f0e", "Netto Zuwachs" = "gray50")) +
  labs(
    title = "Kanton-wise Subrubric Counts Ordered by Netto Zuwachs",
    x = "Kanton",
    y = "Number of Records",
    fill = "Subrubric"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    panel.grid.major.y = element_line(color = "grey80"),
    panel.grid.minor.y = element_blank()
  )

# Add Netto Zuwachs as a separate bar without stacking
p + geom_col(data = final_data_kanton, aes(x = kanton, y = NettoZuwachs, fill = "Netto Zuwachs"), width = 0.3, color = "black", position = position_dodge(width = 0.9))
```
```{r}
# Calculate relative contributions of HR01 and HR03
relative_contribution <- complete_data_kanton %>%
  group_by(kanton, subrubric) %>%
  summarise(total_count = sum(count), .groups = 'drop') %>%
  group_by(kanton) %>%
  mutate(percentage = total_count / sum(total_count) * 100)

# Order Kantons by the percentage of HR01
ordered_kantons <- relative_contribution %>%
  filter(subrubric == "HR01") %>%
  arrange(desc(percentage)) %>%
  pull(kanton)

relative_contribution <- relative_contribution %>%
  mutate(kanton = factor(kanton, levels = ordered_kantons))

# Plot relative contributions by Kanton
ggplot(relative_contribution, aes(x = kanton, y = percentage, fill = subrubric)) +
  geom_bar(stat = "identity") +
  coord_flip() +  # Flip coordinates for better readability
  labs(
    title = "Relative Contribution of HR01 and HR03 by Kanton",
    x = "Kanton",
    y = "Percentage",
    fill = "Subrubric"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  )

```

```{r}
dp <- 5
relative_contribution2 <- relative_contribution %>%
  arrange(kanton, subrubric) %>%
  group_by(kanton) %>%
  mutate(y_text = percentage[2] + c(1, -1) * dp)
```


```{r}
# Plot with y-axis range limitation and visible labels
ggplot(relative_contribution, aes(x = kanton, y = percentage, fill = subrubric)) +
  geom_bar(stat = "identity", color = "black") +  # Keep bar borders
  coord_flip() +  # Flip coordinates for better readability
  coord_cartesian(ylim = c(30, 50)) +  # Set y-axis range to zoom in
  geom_text(
    aes(label = round(percentage, 1)), 
    position = position_stack(vjust = 0.5), 
    size = 3, 
    color = "black"  # Choose a color that contrasts with the bar color
  ) +  
  labs(
    title = "Relative Contribution of HR01 and HR03 by Kanton",
    x = "Kanton",
    y = "Percentage",
    fill = "Subrubric"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  )


```


```{r}
# Plot with separate label positions for HR01 and HR03
ggplot(relative_contribution2, aes(x = kanton, y = percentage, fill = subrubric)) +
  geom_col(color = "black") +  # Keep bar borders
  #coord_flip() +  # Flip coordinates for better readability
  coord_cartesian(ylim = c(30, 50)) +  # Set y-axis range to zoom in
  
  # Labels for HR01 at the bottom of the bars
  geom_text(
    aes(label = round(percentage, 1), y = y_text), 
    size = 3, 
    color = "black"
  ) +

  labs(
    title = "Relative Contribution of HR01 and HR03 by Kanton",
    x = "Kanton",
    y = "Percentage",
    fill = "Subrubric"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  )


```

```{r,fig.width=10, fig.height=10, echo=FALSE}
# Load necessary libraries
library(ggplot2)
library(dplyr)
library(patchwork)  # For combining plots into a grid

# Ensure that the date is in Date format and extract the year
data$date <- as.Date(data$date)
data$year <- format(data$date, "%Y")

# Aggregate the data by year, kanton, and subrubric, then calculate percentages
agg_data <- data %>%
  group_by(year, kanton, subrubric) %>%
  summarise(total_count = n(), .groups = 'drop') %>%
  group_by(year, kanton) %>%
  mutate(percentage = total_count / sum(total_count) * 100)

# Create the overview plot with data over all years
overview_plot <- ggplot(agg_data, aes(x = kanton, y = percentage, fill = subrubric)) +
  geom_bar(stat = "identity", width = 0.8) +
  labs(
    title = "Overall Contribution of HR01 and HR03 by Kanton",
    fill = "Subrubric"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.text.y = element_text(size = 10),
    axis.title.x = element_blank(),  # Remove x-axis title
    axis.title.y = element_blank(),  # Remove y-axis title
    legend.position = "top",  # Legend at the top
    legend.direction = "horizontal"
  )

# Create an empty list to store the plots
plots <- list()

# Loop through each year
for (yr in unique(agg_data$year)) {
  
  # Filter the data for the current year
  year_data <- agg_data %>% filter(year == yr)
  
  # Determine the order of Kantons based on HR01 percentage within the current year
  hr01_order <- year_data %>%
    filter(subrubric == "HR01") %>%
    arrange(desc(percentage)) %>%
    pull(kanton)
  
  # Apply the ordering to the year's data
  year_data <- year_data %>%
    mutate(kanton = factor(kanton, levels = hr01_order))
  
  # Create the plot for the current year without the legend
  p <- ggplot(year_data, aes(x = kanton, y = percentage, fill = subrubric)) +
    geom_bar(stat = "identity", width = 0.8) +
    labs(
      title = paste(yr)
    ) +
    theme_minimal() +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1),
      axis.text.y = element_text(size = 10),
      strip.text = element_text(size = 12),
      axis.title.x = element_blank(),  # Remove x-axis title
      axis.title.y = element_blank(),  # Remove y-axis title
      legend.position = "none"  # Remove legend from individual plots
    ) +
    coord_cartesian(ylim = c(30, 55))  # Adjust the y-axis limits with coord_cartesian
  
  # Store the plot in the list
  plots[[yr]] <- p
}

# Combine the overview plot with the individual year plots using patchwork
final_plot <- (overview_plot / wrap_plots(plots, ncol = 2)) + 
  plot_layout(heights = c(2, 10)) +  # Adjust the heights for overview and year plots
  plot_annotation(title = "Relative Contribution of HR01 and HR03 by Year and Kanton")

# Display the combined plot grid
final_plot



```

```{r warning=FALSE}

# Convert the date column to Date type
shab_data$date <- as.Date(shab_data$date)

# Extract year and month from the date
shab_data$year_month <- format(shab_data$date, "%Y-%m")

# Filter data for subrubric HR01 and HR03
hr01_data <- subset(shab_data, subrubric == "HR01")
hr03_data <- subset(shab_data, subrubric == "HR03")

# Count occurrences by year_month
hr01_counts <- aggregate(id ~ year_month, data = hr01_data, FUN = length)
hr03_counts <- aggregate(id ~ year_month, data = hr03_data, FUN = length)

# Rename columns for merging
colnames(hr01_counts) <- c("year_month", "HR01_count")
colnames(hr03_counts) <- c("year_month", "HR03_count")

# Merge the data on year_month
monthly_counts <- merge(hr01_counts, hr03_counts, by = "year_month", all = TRUE)
monthly_counts[is.na(monthly_counts)] <- 0

# Calculate the difference
monthly_counts$difference <- monthly_counts$HR01_count - monthly_counts$HR03_count

# Normalize the difference for plotting
max_count <- max(monthly_counts$HR01_count, monthly_counts$HR03_count)
max_difference <- max(abs(monthly_counts$difference))
scale_factor <- max_count / max_difference
monthly_counts$scaled_difference <- monthly_counts$difference * scale_factor

# Create the plot with a secondary y-axis
ggplot(monthly_counts, aes(x = as.Date(paste0(year_month, "-01")))) +
  geom_line(aes(y = HR01_count, color = "HR01 Count")) +
  geom_line(aes(y = HR03_count, color = "HR03 Count")) +
  geom_line(aes(y = scaled_difference, color = "Difference")) +
  scale_y_continuous(
    name = "Count",
    sec.axis = sec_axis(~ . / scale_factor, name = "Difference")
  ) +
  labs(title = "Monthly Counts and Differences",
       x = "Month",
       color = "Legend") +
  theme_minimal() +
  theme(legend.position = "bottom")

```
```{r}
# Create a quarter-year column
shab_data$quarter_year <- floor_date(shab_data$date, "quarter")
# Summarize the data for line plot
shab_data_summary <- shab_data %>%
  group_by(quarter_year, kanton, subrubric) %>%
  summarise(entries = n()) %>%
  ungroup()
# Line Plot: Number of entries over time by subrubric, faceted by kanton
ggplot(shab_data_summary, aes(x = quarter_year, y = entries, color = subrubric)) +
  geom_line() +
  labs(title = "Number of Entries Over Time by Subrubric and Kanton", x = "Quarter-Year", y = "Number of Entries") +
  facet_wrap(~ kanton, scales = "free_y") +
  theme_minimal() +
  theme(legend.position = "bottom",
        plot.title = element_text(size = 14),
        axis.title = element_text(size = 10),
        axis.text = element_text(size = 8),
        strip.text = element_text(size = 8),
        legend.text = element_text(size = 8),
        axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
```

```{r warning=FALSE}


# Calculate the net change for each month
monthly_counts$net_change <- monthly_counts$HR01_count - monthly_counts$HR03_count

# Calculate the cumulative sum of the net changes
monthly_counts$cumulative_total <- cumsum(monthly_counts$net_change)

# Create the cumulative total plot
plot_cumulative <- ggplot(monthly_counts, aes(x = as.Date(paste0(year_month, "-01")))) +
  geom_line(aes(y = cumulative_total, color = "Cumulative Total")) +
  labs(title = "Cumulative Total Over Time",
       x = "Month",
       y = "Cumulative Total",
       color = "Legend") +
  theme_minimal() +
  guides(color = guide_legend(title = "Cumulative Total"))

# Create the log scale plot without the legend
plot_log_scale <- ggplot(monthly_counts, aes(x = as.Date(paste0(year_month, "-01")))) +
  geom_line(aes(y = cumulative_total, color = "Cumulative Total")) +
  scale_y_log10() +
  labs(title = "Cumulative Total Over Time (Log Scale)",
       x = "Month",
       y = "Cumulative Total (Log Scale)") +
  theme_minimal() +
  theme(legend.position = "none")

# Combine the two plots using patchwork
combined_plot <- plot_cumulative + plot_log_scale + plot_layout(ncol = 2)

# Print the combined plot
print(combined_plot)
```


```{r warning=FALSE}

# Count occurrences by date
hr01_counts_daily <- hr01_data %>%
  group_by(date) %>%
  summarise(HR01_count = n())

hr03_counts_daily <- hr03_data %>%
  group_by(date) %>%
  summarise(HR03_count = n())

# Merge the data on date
daily_counts <- merge(hr01_counts_daily, hr03_counts_daily, by = "date", all = TRUE)
daily_counts[is.na(daily_counts)] <- 0

# Calculate the difference
daily_counts$difference <- daily_counts$HR01_count - daily_counts$HR03_count

# Perform linear regression on HR01_count and HR03_count
lm_model_daily <- lm(HR01_count ~ HR03_count, data = daily_counts)

# Summarize the model
summary(lm_model_daily)

# Extract tidy results with confidence intervals and p-values
tidy_results_daily <- tidy(lm_model_daily, conf.int = TRUE)
tidy_results_daily

# Plot regression line with confidence interval
ggplot(daily_counts, aes(x = HR03_count, y = HR01_count, colour = factor(wday(date)))) +
  geom_point() +
  geom_smooth(method = "lm", se = TRUE) +
  labs(title = "Linear Regression of HR01 Count on HR03 Count (Daily Data)",
       x = "HR03 Count",
       y = "HR01 Count") +
  theme_minimal()
```

```{r}
ggplot(daily_counts, aes(x = HR03_count, y = HR01_count)) +
  geom_point() +
  geom_smooth(method = "lm", se = TRUE) +
  labs(title = "Linear Regression of HR01 Count on HR03 Count (Daily Data)",
       x = "HR03 Count",
       y = "HR01 Count") +
  theme_minimal()
```



```{r}

count_per_date <- shab_data %>%
  group_by(date, subrubric) %>%
  summarise(count = n())

hr03_data <- count_per_date %>% filter(subrubric == "HR03")
hr01_data <- count_per_date %>% filter(subrubric == "HR01")

fit_hr03 <- lm(count ~ date, data = hr03_data)
fit_hr01 <- lm(count ~ date, data = hr01_data)

intercept_hr03 <- coef(fit_hr03)[1]
slope_hr03 <- coef(fit_hr03)[2]

intercept_hr01 <- coef(fit_hr01)[1]
slope_hr01 <- coef(fit_hr01)[2]

# Plot both subrubrics in the same plot with thicker regression lines
ggplot(count_per_date, aes(x = date, y = count, color = subrubric)) +
  geom_point() +
  geom_abline(intercept = intercept_hr03, slope = slope_hr03, color = "blue", size = 1.2, linetype = "solid") +
  geom_abline(intercept = intercept_hr01, slope = slope_hr01, color = "red", size = 1.2, linetype = "solid") +
  labs(title = "Regression of Subrubric HR03 and HR01 Counts Over Time",
       x = "Date",
       y = "Count",
       color = "Subrubric") +
  scale_color_manual(values = c("HR03" = "blue", "HR01" = "red")) +
  theme_minimal()

```

```{r warning=FALSE}
current_year <- format(Sys.Date(), "%Y")
# Convert the date column to Date type
shab_data$date <- as.Date(shab_data$date)

# Extract month and year from the date
shab_data$month <- format(shab_data$date, "%m")
shab_data$year <- format(shab_data$date, "%Y")

# Process HR03 data
hr03_data <- subset(shab_data, subrubric == "HR03")
hr03_counts <- hr03_data %>%
  group_by(year, month) %>%
  summarise(count = n(), .groups = 'drop')

# Process HR01 data
hr01_data <- subset(shab_data, subrubric == "HR01")
hr01_counts <- hr01_data %>%
  group_by(year, month) %>%
  summarise(count = n(), .groups = 'drop')

# Define line sizes
line_size_current <- 1
line_size_other <- 0.5

# Create the HR03 plot with adjusted line sizes
plot_hr03 <- ggplot(hr03_counts, aes(x = month, y = count, group = year, color = year)) +
  geom_line(aes(size = ifelse(year == current_year, line_size_current, line_size_other))) +
  labs(title = "Monthly HR03 Counts by Year",
       x = "Month",
       y = "Count",
       color = "Year") +
  scale_x_discrete(limits = sprintf("%02d", 1:12)) +
  theme_minimal() +
  scale_size_identity() +  # Ensure size is used as is
  guides(size = "none")

# Create the HR01 plot with adjusted line sizes
plot_hr01 <- ggplot(hr01_counts, aes(x = month, y = count, group = year, color = year)) +
  geom_line(aes(size = ifelse(year == current_year, line_size_current, line_size_other))) +
  labs(title = "Monthly HR01 Counts by Year",
       x = "Month",
       y = "Count",
       color = "Year") +
  scale_x_discrete(limits = sprintf("%02d", 1:12)) +
  theme_minimal() +
  scale_size_identity() +  # Ensure size is used as is
  guides(size = "none")

# Combine the plots using patchwork
combined_plot <- plot_hr03 + plot_hr01 + plot_layout(ncol = 1, heights = c(1, 1))

# Print the combined plot
print(combined_plot)
```
```{r}
# Load necessary libraries
library(ggplot2)
library(dplyr)
library(patchwork)

# Convert the date column to Date type
shab_data$date <- as.Date(shab_data$date)

# Extract month and year from the date
shab_data$month <- format(shab_data$date, "%m")
shab_data$year <- format(shab_data$date, "%Y")

# Group years into the desired pairs
shab_data$year_group <- case_when(
  shab_data$year %in% c("2018", "2019") ~ "2018-2019",
  shab_data$year %in% c("2020", "2021") ~ "2020-2021",
  shab_data$year %in% c("2022", "2023") ~ "2022-2023",
  shab_data$year == "2024" ~ "2024",
  TRUE ~ NA_character_
)

# Process HR03 data
hr03_data <- subset(shab_data, subrubric == "HR03" & !is.na(year_group))
hr03_means <- hr03_data %>%
  group_by(year_group, month) %>%
  summarise(mean_count = mean(n()), .groups = 'drop')

# Process HR01 data
hr01_data <- subset(shab_data, subrubric == "HR01" & !is.na(year_group))
hr01_means <- hr01_data %>%
  group_by(year_group, month) %>%
  summarise(mean_count = mean(n()), .groups = 'drop')

# Create the HR03 plot with adjusted line sizes
plot_hr03 <- ggplot(hr03_means, aes(x = month, y = mean_count, group = year_group, color = year_group)) +
  geom_line(size = 1) +
  labs(title = "Monthly HR03 Mean Counts by Year Groups",
       x = "Month",
       y = "Mean Count",
       color = "Year Group") +
  scale_x_discrete(limits = sprintf("%02d", 1:12)) +
  theme_minimal()

# Create the HR01 plot with adjusted line sizes
plot_hr01 <- ggplot(hr01_means, aes(x = month, y = mean_count, group = year_group, color = year_group)) +
  geom_line(size = 1) +
  labs(title = "Monthly HR01 Mean Counts by Year Groups",
       x = "Month",
       y = "Mean Count",
       color = "Year Group") +
  scale_x_discrete(limits = sprintf("%02d", 1:12)) +
  theme_minimal()

# Combine the plots using patchwork
combined_plot <- plot_hr03 / plot_hr01 + plot_layout(ncol = 1, heights = c(1, 1))

# Print the combined plot
print(combined_plot)

```


```



